import React, { useEffect, useRef, useState } from "react"
import { Button, Input, message, Switch, Divider, List, Tooltip, Space, InputNumber } from "antd"
import ReactJson from "react-json-view"
import "./style.css"
import { loadHistory, saveHistoryItem, clearHistory, removeHistoryItem, type HistoryItem } from "./utils/history"
import { generateTsFromJson } from "./utils/json-to-ts"

const { TextArea } = Input

// 尝试解析可能的 JSON 字符串
const tryParseJSON = (str: string): any => {
  try {
    // 检查是否是 JSON 字符串
    if (typeof str === 'string' && 
        (str.startsWith('{') || str.startsWith('[')) && 
        (str.endsWith('}') || str.endsWith(']'))) {
      return JSON.parse(str)
    }
  } catch (e) {
    // 如果解析失败，返回原始字符串
  }
  return str
}

// 递归处理对象，解析所有可能的 JSON 字符串
const parseNestedJSON = (obj: any): any => {
  if (obj === null || obj === undefined) return obj
  
  if (typeof obj === 'string') {
    return tryParseJSON(obj)
  }
  
  if (Array.isArray(obj)) {
    return obj.map(item => parseNestedJSON(item))
  }
  
  if (typeof obj === 'object') {
    const result: any = {}
    for (const [key, value] of Object.entries(obj)) {
      result[key] = parseNestedJSON(value)
    }
    return result
  }
  
  return obj
}

const IndexPopup = () => {
  const [inputValue, setInputValue] = useState("")
  const [parsedValue, setParsedValue] = useState<any>(null)
  const [error, setError] = useState("")
  const [autoDecode, setAutoDecode] = useState(true)
  const [sortKeys, setSortKeys] = useState(false)
  const [steps, setSteps] = useState<string[]>([])
  const [history, setHistory] = useState<HistoryItem[]>([])
  const [searchTerm, setSearchTerm] = useState("")
  const [searchResults, setSearchResults] = useState<string[]>([])
  const [loadingHistory, setLoadingHistory] = useState(false)
  const [expandedPaths, setExpandedPaths] = useState<string[]>([])
  const [selectedPath, setSelectedPath] = useState<string>("")
  const [clipPerm, setClipPerm] = useState<boolean | null>(null)
  const [collapseDepth, setCollapseDepth] = useState<number>(2)
  const [jumpPath, setJumpPath] = useState<string>("")
  const [perfMode, setPerfMode] = useState<boolean>(false)
  const [forceRenderAll, setForceRenderAll] = useState<boolean>(false)
  const [schemaText, setSchemaText] = useState<string>("")
  const [schemaResult, setSchemaResult] = useState<{
    ok: boolean
    errors?: Array<{ path: string; message: string; keyword?: string }>
  } | null>(null)
  const [schemaBusy, setSchemaBusy] = useState<boolean>(false)
  // TS 类型生成功能
  const [tsCode, setTsCode] = useState<string>("")
  const [tsRootName, setTsRootName] = useState<string>("Root")
  const [tsBusy, setTsBusy] = useState<boolean>(false)
  const [tsSample, setTsSample] = useState<number>(100)
  const [tsEnumMode, setTsEnumMode] = useState<boolean>(true)
  const [tsEnumMax, setTsEnumMax] = useState<number>(8)
  const [tsEnumMaxLen, setTsEnumMaxLen] = useState<number>(32)
  const [tsEnumNumberMode, setTsEnumNumberMode] = useState<boolean>(true)
  const [tsEnumNumMax, setTsEnumNumMax] = useState<number>(8)
  const [tsDetectDate, setTsDetectDate] = useState<boolean>(false)
  const [tsAggressive, setTsAggressive] = useState<boolean>(false)
  const [tsEditMode, setTsEditMode] = useState<boolean>(false)

  const applyModePreset = (aggressive: boolean) => {
    setTsAggressive(aggressive)
    if (aggressive) {
      setTsSample(200)
      setTsEnumMode(true)
      setTsEnumMax(16)
      setTsEnumMaxLen(64)
      setTsEnumNumberMode(true)
      setTsEnumNumMax(16)
      setTsDetectDate(true)
    } else {
      setTsSample(100)
      setTsEnumMode(true)
      setTsEnumMax(8)
      setTsEnumMaxLen(32)
      setTsEnumNumberMode(true)
      setTsEnumNumMax(8)
      setTsDetectDate(false)
    }
  }

  useEffect(() => {
    // 加载历史记录
    setLoadingHistory(true)
    loadHistory().then(setHistory).finally(() => setLoadingHistory(false))
  }, [])

  // 检查可选权限当前状态
  useEffect(() => {
    const checkClipboardPermission = async (): Promise<boolean> => {
      try {
        if (!chrome?.permissions) return true
        const perms: string[] = ["clipboardRead", "clipboardWrite"]
        const has = await new Promise<boolean>((resolve) => {
          chrome.permissions.contains({ permissions: perms }, (granted) => resolve(Boolean(granted)))
        })
        return has
      } catch {
        return true
      }
    }
    checkClipboardPermission().then(setClipPerm).catch(() => setClipPerm(null))
  }, [])

  // —— 容错解析与解码工具 ——
  const isLikelyBase64 = (s: string) =>
    /^[A-Za-z0-9+/_-]+={0,2}$/.test(s.replace(/\s+/g, "")) && s.replace(/\s+/g, "").length % 4 === 0

  const base64ToUtf8 = (b64: string) => {
    const norm = b64.replace(/-/g, "+").replace(/_/g, "/")
    const pad = "=".repeat((4 - (norm.length % 4 || 4)) % 4)
    const bin = atob(norm + pad)
    try {
      // 处理 UTF-8
      return decodeURIComponent(escape(bin))
    } catch {
      return bin
    }
  }

  const tryUrlDecode = (s: string): string | null => {
    try {
      const once = decodeURIComponent(s)
      return once.includes("%") ? decodeURIComponent(once) : once
    } catch {
      return null
    }
  }

  const tryBase64Decode = (s: string): string | null => {
    if (!isLikelyBase64(s)) return null
    try {
      return base64ToUtf8(s)
    } catch {
      return null
    }
  }

  const tryJwtDecode = (s: string): string | null => {
    const parts = s.split(".")
    if (parts.length !== 3) return null
    try {
      return base64ToUtf8(parts[1])
    } catch {
      return null
    }
  }

  // 从混杂日志里提取第一个完整 JSON（对象或数组）
  const extractFirstJson = (text: string): string | null => {
    let start = -1
    const stack: string[] = []
    let inStr = false
    let strCh = ""
    let esc = false

    for (let i = 0; i < text.length; i++) {
      const ch = text[i]
      if (inStr) {
        if (esc) {
          esc = false
        } else if (ch === "\\") {
          esc = true
        } else if (ch === strCh) {
          inStr = false
          strCh = ""
        }
        continue
      }
      if (ch === '"' || ch === "'") {
        inStr = true
        strCh = ch
        continue
      }
      if (ch === "{" || ch === "[") {
        if (stack.length === 0) start = i
        stack.push(ch)
        continue
      }
      if (ch === "}" || ch === "]") {
        const last = stack[stack.length - 1]
        if ((last === "{" && ch === "}") || (last === "[" && ch === "]")) {
          stack.pop()
          if (stack.length === 0 && start !== -1) {
            const cand = text.slice(start, i + 1)
            try {
              JSON.parse(cand)
              return cand
            } catch {
              // 继续寻找
            }
          }
        } else {
          // 括号不匹配，重置
          stack.length = 0
          start = -1
        }
      }
    }
    return null
  }

  type SmartOptions = {
    autoDecode?: boolean
    sortKeys?: boolean
    parseNested?: boolean
  }

  const sortKeysDeep = (v: any): any => {
    if (Array.isArray(v)) return v.map(sortKeysDeep)
    if (v && typeof v === "object") {
      return Object.keys(v)
        .sort()
        .reduce((acc, k) => {
          acc[k] = sortKeysDeep((v as any)[k])
          return acc
        }, {} as any)
    }
    return v
  }

  const parseSmart = (raw: string, opt: SmartOptions = {}) => {
    const steps: string[] = []
    const tryJson = (s: string) => {
      const trimmed = s.trim()
      try {
        const obj = JSON.parse(trimmed)
        steps.push("直接 JSON.parse 成功")
        return obj
      } catch {}
      return null
    }

    let obj = tryJson(raw)
    if (!obj && opt.autoDecode) {
      const url = tryUrlDecode(raw)
      if (url && !obj) {
        obj = tryJson(url)
        if (obj) steps.push("URL 解码后解析成功")
      }
      if (!obj) {
        const jwt = tryJwtDecode(raw)
        if (jwt) {
          obj = tryJson(jwt) ?? tryJson(tryUrlDecode(jwt) ?? jwt)
          if (obj) steps.push("JWT 解码负载后解析成功")
        }
      }
      if (!obj) {
        const b64 = tryBase64Decode(raw)
        if (b64) {
          obj = tryJson(b64) ?? tryJson(tryUrlDecode(b64) ?? b64)
          if (obj) steps.push("Base64 解码后解析成功")
        }
      }
    }
    // 尝试解析 URL 的查询参数/哈希参数
    if (!obj) {
      try {
        const u = new URL(raw.trim())
        const toKV = (sp: URLSearchParams) => {
          const out: any = {}
          sp.forEach((v, k) => {
            // 对每个值尝试 URL/JWT/Base64 的解码后再 JSON.parse
            const cand =
              tryJson(v) ||
              tryJson(tryUrlDecode(v) ?? v) ||
              (() => {
                const j = tryJwtDecode(v)
                return j ? (tryJson(j) || tryJson(tryUrlDecode(j) ?? j)) : null
              })() ||
              (() => {
                const b = tryBase64Decode(v)
                return b ? (tryJson(b) || tryJson(tryUrlDecode(b) ?? b)) : null
              })() ||
              v
            if (k in out) {
              const prev = out[k]
              out[k] = Array.isArray(prev) ? [...prev, cand] : [prev, cand]
            } else {
              out[k] = cand
            }
          })
          return out
        }
        const queryObj = toKV(u.searchParams)
        const hashObj = u.hash ? toKV(new URLSearchParams(u.hash.replace(/^#\??/, ""))) : {}
        const payload = { url: u.origin + u.pathname, ...queryObj, ...(Object.keys(hashObj).length ? { hash: hashObj } : {}) }
        if (Object.keys(payload).length > 1) {
          obj = payload
          steps.push("从 URL 参数解析成功")
        }
      } catch {}
    }
    if (!obj) {
      const sub = extractFirstJson(raw)
      if (sub) {
        obj = tryJson(sub)
        if (obj) steps.push("从日志中提取子串解析成功")
      }
    }
    if (!obj) throw new Error("未能解析出有效 JSON")

    const finalObj = opt.parseNested ? parseNestedJSON(obj) : obj
    const output = opt.sortKeys ? sortKeysDeep(finalObj) : finalObj
    return { data: output, steps }
  }

  // —— 权限与剪贴板 ——
  // 动态申请可选权限：clipboardRead/clipboardWrite（manifest 的 optional_permissions 中声明）
  const ensureClipboardPermission = async (): Promise<boolean> => {
    try {
      // 在扩展环境下可用
      if (!chrome?.permissions) return true
      const perms: string[] = ["clipboardRead", "clipboardWrite"]

      const has = await new Promise<boolean>((resolve) => {
        chrome.permissions.contains({ permissions: perms }, (granted) => resolve(Boolean(granted)))
      })
      if (has) return true

      const granted = await new Promise<boolean>((resolve) => {
        chrome.permissions.request({ permissions: perms }, (ok) => resolve(Boolean(ok)))
      })
      return granted
    } catch {
      // 某些环境（如非扩展页）不支持 permissions API，则跳过
      return true
    }
  }

  const handleRequestClipboardPermission = async () => {
    const ok = await ensureClipboardPermission()
    setClipPerm(ok)
    if (ok) message.success("已授予剪贴板权限")
    else message.error("未授予剪贴板权限")
  }

  // —— 读剪贴板与导出 ——
  const readClipboardText = async (): Promise<string> => {
    // 稳健读取：预检权限 + 焦点检查 + 细分错误信息
    try {
      // 先确保可选权限（如用户未授予时触发授权弹窗）
      const ok = await ensureClipboardPermission()
      if (!ok) {
        throw Object.assign(new Error('用户未授权剪贴板权限'), { name: 'NotAllowedError' })
      }

      const anyNav = navigator as any
      // 预检剪贴板权限（部分浏览器支持），若被拒绝则直接提示
      try {
        const perm = await anyNav?.permissions?.query?.({ name: 'clipboard-read' as any })
        if (perm?.state === 'denied') {
          const err = new Error('读取剪贴板被浏览器设置拒绝，请在浏览器的站点/隐私设置中允许“读取剪贴板”')
          ;(err as any).name = 'NotAllowedError'
          throw err
        }
      } catch {
        // 忽略不支持 permissions 的情况
      }

      // 尝试确保弹窗获得焦点，避免 DocumentNotFocused 错误
      if (!document.hasFocus()) {
        await new Promise((r) => setTimeout(r, 50))
      }

      return await navigator.clipboard.readText()
    } catch (e: any) {
      // 输出详细日志便于定位真实原因
      console.error('Clipboard read failed:', e?.name, e?.message, e)
      const msg = (() => {
        if (e?.name === 'NotAllowedError') {
          return '读取剪贴板被拒绝：请检查扩展是否授予剪贴板权限，或在浏览器设置中放行'
        }
        const m = String(e?.message || '')
        if (m.includes('Document is not focused') || m.toLowerCase().includes('focus')) {
          return '读取失败：当前弹窗未获得焦点，请先点击弹窗后再试'
        }
        if (m.toLowerCase().includes('permission') || m.toLowerCase().includes('denied')) {
          return '读取失败：浏览器或站点权限限制，请在设置中允许读取剪贴板'
        }
        return '无法读取剪贴板内容，请授予权限或手动粘贴'
      })()
      throw new Error(msg)
    }
  }

  const downloadJson = (data: any, filename = "parsed.json") => {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = filename
    a.click()
    URL.revokeObjectURL(url)
  }

  const downloadText = (text: string, filename = "data.txt") => {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = filename
    a.click()
    URL.revokeObjectURL(url)
  }

  // —— TypeScript 类型生成 ——
  const handleGenTs = () => {
    if (!parsedValue) {
      message.warning("请先解析出 JSON")
      return
    }
    try {
      setTsBusy(true)
      const code = generateTsFromJson(parsedValue, {
        rootName: tsRootName || "Root",
        arraySample: tsSample,
        enumStrings: tsEnumMode ? 'auto' : false,
        enumMaxUnique: tsEnumMax,
        enumMaxLength: tsEnumMaxLen,
        enumNumbers: tsEnumNumberMode ? 'auto' : false,
        enumNumMaxUnique: tsEnumNumMax,
        detectDate: tsDetectDate
      })
      setTsCode(code)
      message.success("已生成类型")
    } catch (e) {
      console.error("TS 生成失败", e)
      message.error("类型生成失败")
    } finally {
      setTsBusy(false)
    }
  }

  const formatTsLocal = (code: string): string => {
    if (!code) return code
    // 简单格式化：
    // - 移除多余空格行（>2 行收敛为 1 行）
    // - 接口之间空一行
    // - 末尾加换行
    const lines = code.split(/\r?\n/)
    const out: string[] = []
    let blank = 0
    for (const ln of lines) {
      if (/^\s*$/.test(ln)) {
        blank++
        if (blank <= 1) out.push("")
      } else {
        blank = 0
        out.push(ln.replace(/\s+$/g, ""))
      }
    }
    const s = out.join("\n").replace(/\n{3,}/g, "\n\n")
    return s.endsWith("\n") ? s : s + "\n"
  }

  // —— 轻量 TypeScript 语法高亮（零依赖） ——
  const escapeHtml = (s: string): string =>
    s
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#39;")

  const highlightNormalChunk = (raw: string): string => {
    // 基于 token 的简单扫描，避免在已插入的标签内再次替换导致破坏 HTML
    const kw = new Set([
      'export','interface','type','extends','implements','enum','const','let','var','function','return','readonly','as','keyof','in','of','new'
    ])
    const types = new Set([
      'string','number','boolean','unknown','null','any','never','void','Date','Record','Partial','Pick','Omit','Readonly','Required','NonNullable','Parameters','ReturnType','InstanceType'
    ])
    let out = ''
    let i = 0
    const n = raw.length
    while (i < n) {
      const ch = raw[i]
      // 数字
      if (ch >= '0' && ch <= '9') {
        const m = raw.slice(i).match(/^\d+(?:\.\d+)?/)
        if (m) {
          out += `<span class="hl-num">${escapeHtml(m[0])}</span>`
          i += m[0].length
          continue
        }
      }
      // 标识符/关键字/类型
      if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch === '_' || ch === '$') {
        const m = raw.slice(i).match(/^[A-Za-z_$][A-Za-z0-9_$]*/)
        if (m) {
          const tok = m[0]
          if (kw.has(tok)) out += `<span class="hl-kw">${tok}</span>`
          else if (types.has(tok)) out += `<span class="hl-type">${tok}</span>`
          else out += escapeHtml(tok)
          i += tok.length
          continue
        }
      }
      out += escapeHtml(ch)
      i++
    }
    return out
  }

  const highlightTs = (code: string): string => {
    let out = ""
    let i = 0
    const n = code.length
    let mode: 'normal'|'squote'|'dquote'|'bquote'|'linecom'|'blockcom' = 'normal'
    let buf = ""
    const flush = () => {
      if (!buf) return
      if (mode === 'normal') out += highlightNormalChunk(buf)
      else if (mode === 'linecom' || mode === 'blockcom') out += `<span class="hl-com">${escapeHtml(buf)}</span>`
      else out += `<span class="hl-str">${escapeHtml(buf)}</span>`
      buf = ""
    }
    while (i < n) {
      const ch = code[i]
      const next = i + 1 < n ? code[i + 1] : ''
      if (mode === 'normal') {
        if (ch === '/' && next === '/') {
          flush()
          mode = 'linecom'
          buf += ch; i++
          buf += next; i++
          continue
        }
        if (ch === '/' && next === '*') {
          flush()
          mode = 'blockcom'
          buf += ch; i++
          buf += next; i++
          continue
        }
        if (ch === '"') { flush(); mode = 'dquote'; buf += ch; i++; continue }
        if (ch === "'") { flush(); mode = 'squote'; buf += ch; i++; continue }
        if (ch === '`') { flush(); mode = 'bquote'; buf += ch; i++; continue }
        buf += ch
        i++
        continue
      }
      if (mode === 'linecom') {
        buf += ch
        i++
        if (ch === '\n') { flush(); mode = 'normal' }
        continue
      }
      if (mode === 'blockcom') {
        buf += ch
        i++
        if (ch === '*' && next === '/') { buf += next; i++; flush(); mode = 'normal' }
        continue
      }
      // 字符串/模板字面量，处理转义
      if (mode === 'dquote') {
        buf += ch
        i++
        if (ch === '\\') { if (i < n) { buf += code[i]; i++ } }
        else if (ch === '"') { flush(); mode = 'normal' }
        continue
      }
      if (mode === 'squote') {
        buf += ch
        i++
        if (ch === '\\') { if (i < n) { buf += code[i]; i++ } }
        else if (ch === "'") { flush(); mode = 'normal' }
        continue
      }
      if (mode === 'bquote') {
        buf += ch
        i++
        if (ch === '\\') { if (i < n) { buf += code[i]; i++ } }
        else if (ch === '`') { flush(); mode = 'normal' }
        continue
      }
    }
    flush()
    return out
  }

  // —— 搜索路径 ——
  const searchJsonPaths = (root: any, term: string): string[] => {
    if (!term) return []
    const res: string[] = []
    const t = term.toLowerCase()

    const walk = (node: any, path: string) => {
      if (Array.isArray(node)) {
        node.forEach((v, i) => walk(v, `${path}[${i}]`))
        return
      }
      if (node && typeof node === "object") {
        Object.entries(node).forEach(([k, v]) => {
          const keyHit = k.toLowerCase().includes(t)
          const valStr = typeof v === "string" ? v : JSON.stringify(v)
          const valHit = String(valStr).toLowerCase().includes(t)
          const next = `${path}[${JSON.stringify(k)}]`
          if (keyHit || valHit) res.push(next)
          walk(v, next)
        })
        return
      }
      // 原子值匹配
      const valHit = String(node).toLowerCase().includes(t)
      if (valHit) res.push(path)
    }

    walk(root, "$")
    return res.slice(0, 200) // 限制数量
  }

  const handleParse = () => {
    if (!inputValue.trim()) {
      setError("Please enter a JSON string")
      setParsedValue(null)
      message.warning("Please enter a JSON string")
      return
    }

    try {
      const { data, steps } = parseSmart(inputValue, { autoDecode, sortKeys, parseNested: true })
      setParsedValue(data)
      setSteps(steps)
      setError("")
      setSearchResults([])
      setExpandedPaths([])
      setSelectedPath("")
      message.success("Successfully parsed!")
      saveHistoryItem(inputValue, steps).then(() => loadHistory().then(setHistory))
    } catch (err) {
      setError((err as any)?.message || "Invalid JSON string")
      setParsedValue(null)
      message.error((err as any)?.message || "Invalid JSON string")
    }
  }

  const handlePasteAndParse = async () => {
    try {
      const text = await readClipboardText()
      setInputValue(text)
      const { data, steps } = parseSmart(text, { autoDecode, sortKeys, parseNested: true })
      setParsedValue(data)
      setSteps(steps)
      setError("")
      setSearchResults([])
      setExpandedPaths([])
      setSelectedPath("")
      message.success("Parsed from clipboard!")
      saveHistoryItem(text, steps).then(() => loadHistory().then(setHistory))
    } catch (e: any) {
      message.error(e?.message || "读取剪贴板失败")
    }
  }

  const handleExport = () => {
    if (!parsedValue) return
    downloadJson(parsedValue)
  }

  const handleSearch = () => {
    if (!parsedValue || !searchTerm.trim()) {
      setSearchResults([])
      return
    }
    const res = searchJsonPaths(parsedValue, searchTerm.trim())
    setSearchResults(res)
  }

  // —— 路径与展开控制 ——
  const jsonPathToSegments = (p: string): (string | number)[] => {
    // 仅支持形如 $["a"][0]["b"] 的路径
    const segs: (string | number)[] = []
    const re = /\[(.*?)\]/g
    let m: RegExpExecArray | null
    while ((m = re.exec(p))) {
      const inner = m[1]
      if (/^\d+$/.test(inner)) {
        segs.push(Number(inner))
      } else {
        // 去掉引号并处理转义
        const s = inner.trim()
        const q = s[0]
        if (q === '"' || q === "'") {
          try {
            segs.push(JSON.parse(s))
          } catch {
            segs.push(s.slice(1, -1))
          }
        } else {
          segs.push(inner)
        }
      }
    }
    return segs
  }

  const segmentsToJsonPath = (segs: (string | number)[]): string => {
    let out = "$"
    for (const k of segs) {
      if (typeof k === "number" || /^\d+$/.test(String(k))) out += `[${k}]`
      else out += `[${JSON.stringify(String(k))}]`
    }
    return out
  }

  const segmentsToDotPath = (segs: (string | number)[]): string => {
    const isId = (s: string) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(s)
    let out = "$"
    for (const k of segs) {
      if (typeof k === "number") {
        out += `[${k}]`
      } else if (isId(k)) {
        out += `.${k}`
      } else if (/^\d+$/.test(k)) {
        out += `[${k}]`
      } else {
        out += `[${JSON.stringify(k)}]`
      }
    }
    return out
  }

  const getBySegments = (obj: any, segs: (string | number)[]) => {
    let cur = obj
    for (const k of segs) {
      if (cur == null) return undefined
      cur = (cur as any)[k as any]
    }
    return cur
  }

  const exportSearchCsv = () => {
    if (!parsedValue || searchResults.length === 0) return
    // 生成 path,value 两列的 CSV
    const rows = ["path,value"]
    for (const p of searchResults) {
      const segs = jsonPathToSegments(p)
      const val = getBySegments(parsedValue, segs)
      const v = typeof val === "object" ? JSON.stringify(val) : String(val)
      const esc = (s: string) => '"' + s.replace(/"/g, '""') + '"'
      rows.push(`${esc(p)},${esc(v)}`)
    }
    downloadText(rows.join("\n"), "search_hits.csv")
  }

  // —— 性能模式：大对象/数组的虚拟列表渲染（仅根层） ——
  type VirtualItem = { idx: number; key: string | number; value: any; path: string }

  const isLargeRoot = (() => {
    if (!parsedValue) return false
    const ROOT_THRESHOLD = 300 // 根层元素数阈值
    if (Array.isArray(parsedValue)) return parsedValue.length > ROOT_THRESHOLD
    if (parsedValue && typeof parsedValue === 'object') return Object.keys(parsedValue).length > ROOT_THRESHOLD
    return false
  })()

  const buildRootVirtualItems = (): VirtualItem[] => {
    if (!parsedValue) return []
    if (Array.isArray(parsedValue)) {
      return parsedValue.map((v, i) => ({ idx: i, key: i, value: v, path: `$[${i}]` }))
    }
    if (parsedValue && typeof parsedValue === 'object') {
      return Object.keys(parsedValue).map((k, i) => ({ idx: i, key: k, value: (parsedValue as any)[k], path: `$[${JSON.stringify(k)}]` }))
    }
    return []
  }

  const summarize = (v: any): string => {
    const t = Object.prototype.toString.call(v).slice(8, -1)
    if (v == null) return String(v)
    if (typeof v === 'string') {
      const s = v.length > 120 ? v.slice(0, 117) + '...' : v
      return `string(${v.length}) ${s}`
    }
    if (Array.isArray(v)) return `Array(${v.length})`
    if (typeof v === 'object') return `Object(${Object.keys(v).length})`
    return `${t}: ${String(v)}`
  }

  const VirtualRoot = ({ items, height = 320, itemHeight = 28 }: { items: VirtualItem[]; height?: number; itemHeight?: number }) => {
    const [scrollTop, setScrollTop] = useState(0)
    const total = items.length
    const totalHeight = total * itemHeight
    const visibleCount = Math.ceil(height / itemHeight) + 8 // overscan
    const start = Math.max(0, Math.floor(scrollTop / itemHeight) - 4)
    const end = Math.min(total, start + visibleCount)
    const slice = items.slice(start, end)
    return (
      <div className="border rounded-md bg-gray-50 overflow-auto" style={{ height }} onScroll={(e) => setScrollTop((e.target as HTMLDivElement).scrollTop)}>
        <div style={{ height: totalHeight, position: 'relative' }}>
          {slice.map((it) => {
            const top = it.idx * itemHeight
            return (
              <div key={it.idx} style={{ position: 'absolute', left: 0, right: 0, top, height: itemHeight, display: 'flex', alignItems: 'center', padding: '0 8px' }}>
                <Space size={8}>
                  <code className="text-xs text-gray-600">{typeof it.key === 'number' ? `[${it.key}]` : String(it.key)}</code>
                  <span className="text-gray-700 text-xs">{summarize(it.value)}</span>
                  <Button size="small" onClick={() => handleSelectPath(it.path)}>展开</Button>
                  <Button size="small" onClick={() => handleCopyPath(it.path)}>复制路径</Button>
                  <Button size="small" onClick={() => handleCopyValueAtPath(it.path)} disabled={!parsedValue}>复制值</Button>
                </Space>
              </div>
            )
          })}
        </div>
      </div>
    )
  }

  // —— JSON Schema 校验 ——
  const pointerToJsonPath = (ptr: string): string => {
    // Ajv 错误路径是 JSON Pointer，如 "/a/0/b" 或 "" 表示根
    if (!ptr || ptr === "") return "$"
    const segs = ptr.split('/').slice(1).map((s) => s.replace(/~1/g, '/').replace(/~0/g, '~'))
    let out = "$"
    for (const s of segs) {
      if (/^\d+$/.test(s)) out += `[${s}]`
      else out += `[${JSON.stringify(s)}]`
    }
    return out
  }

  const formatSchema = () => {
    try {
      if (!schemaText.trim()) return
      const obj = JSON.parse(schemaText)
      setSchemaText(JSON.stringify(obj, null, 2))
      message.success("已格式化 Schema")
    } catch (e: any) {
      message.error("Schema 不是合法 JSON")
    }
  }

  const loadSampleSchema = () => {
    const sample = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      type: "object",
      properties: {
        id: { type: "number" },
        name: { type: "string" },
        tags: { type: "array", items: { type: "string" } }
      },
      required: ["id", "name"],
      additionalProperties: true
    }
    setSchemaText(JSON.stringify(sample, null, 2))
  }

  const validateBySchema = async () => {
    if (!parsedValue) {
      message.warning("请先解析出 JSON 再进行校验")
      return
    }
    if (!schemaText.trim()) {
      message.warning("请粘贴或编写 JSON Schema")
      return
    }
    try {
      setSchemaBusy(true)
      const schema = JSON.parse(schemaText)

      const tryAjv = async (): Promise<boolean> => {
        try {
          // 根据 $schema 选择合适的 Ajv 版本/元模式
          const $schema: string | undefined = (schema && typeof schema === 'object') ? (schema as any).$schema : undefined
          const need2020 = typeof $schema === 'string' && /2020-12/.test($schema)
          const need2019 = typeof $schema === 'string' && /2019-09/.test($schema)

          let AjvCtor: any
          if (need2020) {
            const Ajv2020Mod = await import('ajv/dist/2020')
            // @ts-ignore
            AjvCtor = Ajv2020Mod.default || Ajv2020Mod
          } else if (need2019) {
            const Ajv2019Mod = await import('ajv/dist/2019')
            // @ts-ignore
            AjvCtor = Ajv2019Mod.default || Ajv2019Mod
          } else {
            const AjvMod = await import('ajv')
            // @ts-ignore - 动态导入 default
            AjvCtor = AjvMod.default || AjvMod
          }
          let addFormats: any = null
          try {
            const fmt = await import('ajv-formats')
            // @ts-ignore
            addFormats = fmt.default || fmt
          } catch {}
          const ajv = new AjvCtor({ allErrors: true, strict: false, allowUnionTypes: true })
          // 兜底：显式注册元模式，防止“no schema with key or ref …”
          try {
            if (need2020) {
              const meta2020 = await import('ajv/dist/refs/json-schema-2020-12/schema.json')
              ajv.addMetaSchema((meta2020 as any).default || meta2020)
            } else if (need2019) {
              const meta2019 = await import('ajv/dist/refs/json-schema-2019-09/schema.json')
              ajv.addMetaSchema((meta2019 as any).default || meta2019)
            }
          } catch {}
          if (addFormats) addFormats(ajv)
          const validate = ajv.compile(schema)
          const ok = validate(parsedValue)
          if (ok) {
            setSchemaResult({ ok: true })
            message.success("Schema 校验通过")
          } else {
            const errs = (validate.errors || []).map((e: any) => ({
              path: pointerToJsonPath(e.instancePath || e.dataPath || ""),
              message: e.message || "校验失败",
              keyword: e.keyword
            }))
            setSchemaResult({ ok: false, errors: errs })
            message.error(`Schema 未通过：${errs.length} 处问题`)
          }
          return true
        } catch (err: any) {
          // MV3 禁止 unsafe-eval，Ajv 使用 new Function 可能报错，降级到 jsonschema 实现
          const msg = String(err?.message || '')
          const isCspEval = /unsafe-eval|Refused to evaluate|Code generation from strings/i.test(msg)
          if (!isCspEval) {
            // 其他异常也降级试试
            console.warn('Ajv 校验失败，将尝试降级 jsonschema', err)
          } else {
            console.warn('因 MV3 CSP 限制（禁止 eval），Ajv 无法运行，降级为 jsonschema 校验')
          }
          return false
        }
      }

      const tryJsonSchema = async (): Promise<boolean> => {
        try {
          const mod = await import('jsonschema')
          const validate = (mod as any).validate || (mod as any).default?.validate
          if (typeof validate !== 'function') throw new Error('jsonschema 库未正确加载')
          const res = validate(parsedValue, schema)
          if (res.valid) {
            setSchemaResult({ ok: true })
            message.success('Schema 校验通过')
          } else {
            const toPath = (prop: string): string => {
              // 形如 "instance.a.b[0]"
              let p = prop || ''
              if (p.startsWith('instance')) p = p.slice('instance'.length)
              let out = '$'
              const re = /(\.[A-Za-z_$][A-Za-z0-9_$]*)|(\[(\d+)\])/g
              let m: RegExpExecArray | null
              while ((m = re.exec(p))) {
                if (m[1]) {
                  const key = m[1].slice(1)
                  out += `[${JSON.stringify(key)}]`
                } else if (m[3]) {
                  out += `[${m[3]}]`
                }
              }
              return out
            }
            const errs = (res.errors || []).map((e: any) => ({
              path: toPath(e.property || ''),
              message: e.message || '校验失败',
              keyword: e.name || e.keyword
            }))
            setSchemaResult({ ok: false, errors: errs })
            message.error(`Schema 未通过：${errs.length} 处问题`)
          }
          return true
        } catch (err) {
          console.error('jsonschema 校验失败', err)
          return false
        }
      }

      const okAjv = await tryAjv()
      if (!okAjv) {
        const okJson = await tryJsonSchema()
        if (!okJson) throw new Error('两种校验方式均失败')
      }
    } catch (e: any) {
      console.error('Schema validate failed', e)
      message.error("Schema 编译或校验失败，请检查 Schema 是否正确")
    } finally {
      setSchemaBusy(false)
    }
  }

  const nsToJsonPath = (ns: (string | number)[]) => segmentsToJsonPath(ns)

  const resultRef = useRef<HTMLDivElement | null>(null)

  const handleSelectPath = (p: string) => {
    setSelectedPath(p)
    setExpandedPaths((prev) => {
      if (prev.includes(p)) return prev
      return [...prev, p]
    })
    // 等待展开生效后滚动定位
    setTimeout(() => scrollToPath(p), 60)
  }

  const copyText = async (text: string, msg = "已复制") => {
    try {
      const ok = await ensureClipboardPermission()
      if (!ok) {
        message.error("复制失败：未授予剪贴板权限")
        return
      }
      await navigator.clipboard.writeText(text)
      message.success(msg)
    } catch (e: any) {
      const m = String(e?.message || '')
      if (m.toLowerCase().includes('permission') || m.toLowerCase().includes('denied')) {
        message.error("复制失败：浏览器权限限制，请在设置中允许写入剪贴板")
      } else {
        message.error("复制失败")
      }
    }
  }

  const handleCopyPath = (p: string) => copyText(p, "已复制 JSONPath")
  const handleCopyDotPath = (p: string) => {
    const segs = jsonPathToSegments(p)
    const dot = segmentsToDotPath(segs)
    return copyText(dot, "已复制点号路径")
  }
  const handleCopyValueAtPath = (p: string) => {
    const segs = jsonPathToSegments(p)
    const val = getBySegments(parsedValue, segs)
    const text = typeof val === "object" ? JSON.stringify(val, null, 2) : String(val)
    return copyText(text, "已复制值")
  }

  const scrollToPath = (p: string) => {
    const container = resultRef.current
    if (!container) return
    // 尝试按最后一个段对齐行
    const segs = jsonPathToSegments(p)
    const last = segs[segs.length - 1]
    const targetKey = String(last)
    const keyNodes = container.querySelectorAll<HTMLSpanElement>(".object-key")
    let targetRow: HTMLElement | null = null
    for (const el of Array.from(keyNodes)) {
      const raw = (el.textContent || "").trim()
      const norm = raw.replace(/[:\s]+$/, "") // 去掉冒号
      if (norm === targetKey) {
        const row = el.closest<HTMLElement>(".variable-row") || el.parentElement as HTMLElement | null
        if (row) {
          targetRow = row
          break
        }
      }
    }
    if (!targetRow) return
    // 高亮并滚动到视图中
    targetRow.classList.add("rjv-highlight")
    const top = targetRow.offsetTop - (container.offsetTop || 0) - 12
    container.scrollTop = top < 0 ? 0 : top
    // 移除高亮
    setTimeout(() => targetRow?.classList.remove("rjv-highlight"), 1200)
  }

  const handleCopy = (e: any) => {
    // 获取正确的值
    const copyValue = typeof e.src === "object" ? 
      JSON.stringify(e.src, null, 2) : 
      String(e.src)
    
    copyText(copyValue, "Copied to clipboard!")
    return true
  }

  return (
    <div className="w-[900px] min-h-[480px] p-5 bg-white">
      <h1 className="text-2xl font-bold mb-3 text-center text-gray-800">JSON Parser</h1>

      <div className="flex items-center justify-between mb-3">
        <Space size={8}>
          <Button onClick={handlePasteAndParse}>粘贴并解析</Button>
          <Button type="primary" onClick={handleParse}>解析</Button>
          <Button onClick={handleExport} disabled={!parsedValue}>导出 JSON</Button>
          {clipPerm !== true && (
            <Button onClick={handleRequestClipboardPermission}>授权剪贴板</Button>
          )}
        </Space>
        <Space size={16}>
          <span className="text-gray-700">自动解码</span>
          <Switch size="small" checked={autoDecode} onChange={setAutoDecode} />
          <span className="text-gray-700">键名排序</span>
          <Switch size="small" checked={sortKeys} onChange={setSortKeys} />
          <span className="text-gray-700">展开深度</span>
          <InputNumber size="small" min={0} max={8} value={collapseDepth} onChange={(v) => setCollapseDepth((v as number) ?? 2)} />
          {clipPerm === true && <span className="text-green-600 text-xs">已授权剪贴板</span>}
          {clipPerm === false && <span className="text-gray-500 text-xs">未授权</span>}
          {clipPerm === null && <span className="text-gray-400 text-xs">检测中...</span>}
        </Space>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <div className="mb-2 font-medium text-gray-700">输入区：</div>
          <TextArea
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder="粘贴日志或 JSON 字符串... 支持 URL/Base64/JWT 自动解码"
            className="mb-3"
            rows={12}
          />

          <Divider className="my-3" />
          <div className="flex items-center justify-between mb-2">
            <div className="font-medium text-gray-700">历史记录</div>
            <Button danger size="small" onClick={() => clearHistory().then(() => setHistory([]))}>清空</Button>
          </div>
          <div className="border rounded-md p-2 h-[140px] overflow-auto bg-gray-50">
            {loadingHistory ? (
              <div className="text-gray-400 text-sm">加载中...</div>
            ) : history.length === 0 ? (
              <div className="text-gray-400 text-sm">暂无历史记录</div>
            ) : (
              <List
                size="small"
                dataSource={history}
                renderItem={(item) => {
                  const preview = (item.raw || "").slice(0, 100).replace(/\n/g, " ")
                  const time = new Date(item.time).toLocaleString()
                  return (
                    <List.Item className="!py-1">
                      <Space size={8}>
                        <Tooltip title={time}><span className="text-gray-500 text-xs">{time}</span></Tooltip>
                        <Button size="small" onClick={() => setInputValue(item.raw)}>载入</Button>
                        <Button size="small" danger onClick={() => removeHistoryItem(item.id).then(() => loadHistory().then(setHistory))}>删除</Button>
                        <span className="text-gray-700 text-xs truncate max-w-[360px]">{preview}</span>
                      </Space>
                    </List.Item>
                  )
                }}
              />
            )}
          </div>
        </div>

        <div>
          <div className="mb-2 font-medium text-gray-700">解析结果：</div>
          <div className="mb-2">
            {perfMode && isLargeRoot && !forceRenderAll && (
              <div className="text-xs text-gray-600 mb-2">性能模式已启用：根层有大量元素，仅显示虚拟列表。可点击“渲染全部”查看完整树。</div>
            )}
            {perfMode && isLargeRoot && !forceRenderAll ? (
              <>
                <VirtualRoot items={buildRootVirtualItems()} height={320} />
                <div className="mt-2">
                  <Button size="small" onClick={() => setForceRenderAll(true)}>渲染全部</Button>
                </div>
              </>
            ) : (
              <div ref={resultRef} className="border rounded-md p-3 min-h-[288px] bg-gray-50 overflow-auto scroll-smooth">
                {error ? (
                  <div className="text-red-500 text-sm">{error}</div>
                ) : parsedValue ? (
                  <ReactJson
                    src={parsedValue}
                    theme="rjv-default"
                    name={false}
                    collapseStringsAfterLength={30}
                    enableClipboard={handleCopy}
                    displayDataTypes={false}
                    displayObjectSize={false}
                    style={{
                      backgroundColor: 'transparent',
                      fontSize: '13px',
                      fontFamily: 'Monaco, monospace'
                    }}
                    iconStyle="square"
                    shouldCollapse={(field: any) => {
                      // 根据 expandedPaths 强制展开匹配路径；否则按默认深度折叠
                      const ns: (string | number)[] = field?.namespace || []
                      const nsPath = nsToJsonPath(ns)
                      // 兼容部分实现会在 namespace[0] 放置根名的差异
                      const nsPathNoHead = ns.length > 0 ? nsToJsonPath(ns.slice(1)) : nsPath
                      if (expandedPaths.some((ep) => ep.startsWith(nsPath) || nsPath.startsWith(ep) || ep.startsWith(nsPathNoHead) || nsPathNoHead.startsWith(ep))) {
                        return false
                      }
                      const defaultDepth = collapseDepth
                      const depth = ns.length
                      return depth > defaultDepth
                    }}
                  />
                ) : (
                  <div className="text-gray-400">解析结果将显示在此处...</div>
                )}
              </div>
            )}
          </div>

          <div className="mt-3">
            <div className="font-medium text-gray-700 mb-2">搜索路径：</div>
            <div className="flex items-center gap-2 mb-2">
              <Input
                placeholder="输入关键字，匹配键与值（不区分大小写）"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                onPressEnter={handleSearch}
              />
              <Button onClick={handleSearch} disabled={!parsedValue}>搜索</Button>
              {searchResults.length > 0 && (
                <span className="text-gray-600 text-sm">{searchResults.length} 条命中</span>
              )}
              {searchResults.length > 0 && (
                <Button size="small" onClick={() => exportSearchCsv()}>导出命中CSV</Button>
              )}
            </div>
            <div className="flex items-center gap-2 mb-2">
              <Input
                placeholder='输入 JSONPath（如 $["data"][0]["id"]）并跳转'
                value={jumpPath}
                onChange={(e) => setJumpPath(e.target.value)}
                onPressEnter={() => jumpPath && handleSelectPath(jumpPath)}
              />
              <Button onClick={() => jumpPath && handleSelectPath(jumpPath)} disabled={!parsedValue}>跳转</Button>
            </div>
            <div className="border rounded-md p-2 h-[140px] overflow-auto bg-gray-50">
              {searchResults.length === 0 ? (
                <div className="text-gray-400 text-sm">无搜索结果</div>
              ) : (
                <List
                  size="small"
                  dataSource={searchResults}
                  renderItem={(p) => {
                    return (
                      <List.Item className="!py-1">
                        <Space size={6}>
                          <Button size="small" onClick={() => handleSelectPath(p)}>展开</Button>
                          <Button size="small" onClick={() => handleCopyPath(p)}>复制路径</Button>
                          <Button size="small" onClick={() => handleCopyDotPath(p)}>复制点路径</Button>
                          <Button size="small" onClick={() => handleCopyValueAtPath(p)} disabled={!parsedValue}>复制值</Button>
                        </Space>
                        <code className="text-xs ml-2">{p}</code>
                      </List.Item>
                    )
                  }}
                />
              )}
            </div>
            {selectedPath && (
              <div className="text-gray-600 text-xs mt-2">已展开路径：<code>{selectedPath}</code></div>
            )}
            {steps.length > 0 && (
              <div className="text-gray-500 text-xs mt-2">解析步骤：{steps.join(" / ")}</div>
            )}
          </div>

          <Divider className="my-3" />
          <div>
            <div className="font-medium text-gray-700 mb-2">Schema 校验</div>
            <div className="flex items-center gap-2 mb-2">
              <Button onClick={loadSampleSchema} size="small">示例</Button>
              <Button onClick={formatSchema} size="small">格式化</Button>
              <Button type="primary" loading={schemaBusy} onClick={validateBySchema} size="small">校验</Button>
            </div>
            <TextArea
              value={schemaText}
              onChange={(e) => setSchemaText(e.target.value)}
              placeholder='粘贴或编写 JSON Schema（例如 {"type":"object", "properties":{...}}）'
              rows={8}
              className="mb-2"
            />
            {schemaResult && (
              <div className="border rounded-md p-2 bg-gray-50">
                {schemaResult.ok ? (
                  <div className="text-green-600 text-sm">校验通过</div>
                ) : schemaResult.errors && schemaResult.errors.length > 0 ? (
                  <List
                    size="small"
                    dataSource={schemaResult.errors}
                    renderItem={(er) => (
                      <List.Item className="!py-1">
                        <Space size={8}>
                          <Button size="small" onClick={() => handleSelectPath(er.path)}>定位</Button>
                          <Button size="small" onClick={() => handleCopyPath(er.path)}>复制路径</Button>
                        </Space>
                        <span className="text-xs text-gray-700 ml-2">{er.path}</span>
                        <span className="text-xs text-red-600 ml-2">{er.message}</span>
                        {er.keyword && <span className="text-xs text-gray-500 ml-2">({er.keyword})</span>}
                      </List.Item>
                    )}
                  />
                ) : (
                  <div className="text-gray-500 text-xs">无错误</div>
                )}
              </div>
            )}
          </div>

          <Divider className="my-3" />
          <div>
            <div className="font-medium text-gray-700 mb-2">TypeScript 类型生成</div>
            <div className="flex items-center gap-2 mb-2">
              <Input
                size="small"
                style={{ width: 200 }}
                value={tsRootName}
                onChange={(e) => setTsRootName(e.target.value)}
                placeholder="根类型名（默认 Root）"
              />
              <Button onClick={handleGenTs} disabled={!parsedValue} loading={tsBusy}>生成</Button>
              <Button onClick={() => copyText(tsCode, "已复制类型")} disabled={!tsCode}>复制</Button>
              <Button onClick={() => downloadText(tsCode, `${(tsRootName || "types").replace(/\W+/g, "_")}.d.ts`)} disabled={!tsCode}>下载 .d.ts</Button>
              <Button onClick={() => setTsCode((c) => formatTsLocal(c))} disabled={!tsCode}>格式化</Button>
              <Button onClick={() => setTsEditMode((v) => !v)} disabled={!tsCode}>{tsEditMode ? '完成' : '编辑'}</Button>
            </div>
            <div className="flex items-center gap-3 mb-2 text-xs text-gray-700">
              <span>模式（保守/激进）</span>
              <Switch size="small" checked={tsAggressive} onChange={applyModePreset} />
              {tsAggressive ? <span className="text-red-500">激进</span> : <span className="text-gray-600">保守</span>}
            </div>
            <div className="flex items-center gap-3 mb-2 text-xs text-gray-700">
              <span>数组采样</span>
              <InputNumber size="small" min={1} max={1000} value={tsSample} onChange={(v) => setTsSample((v as number) ?? 100)} />
              <span>字符串枚举</span>
              <Switch size="small" checked={tsEnumMode} onChange={setTsEnumMode} />
              <span>最大枚举个数</span>
              <InputNumber size="small" min={1} max={100} value={tsEnumMax} onChange={(v) => setTsEnumMax((v as number) ?? 8)} />
              <span>单值最大长度</span>
              <InputNumber size="small" min={1} max={200} value={tsEnumMaxLen} onChange={(v) => setTsEnumMaxLen((v as number) ?? 32)} />
            </div>
            <div className="flex items-center gap-3 mb-2 text-xs text-gray-700">
              <span>数字枚举</span>
              <Switch size="small" checked={tsEnumNumberMode} onChange={setTsEnumNumberMode} />
              <span>最大个数</span>
              <InputNumber size="small" min={1} max={100} value={tsEnumNumMax} onChange={(v) => setTsEnumNumMax((v as number) ?? 8)} />
              <span>识别日期字符串</span>
              <Switch size="small" checked={tsDetectDate} onChange={setTsDetectDate} />
            </div>
            {tsEditMode ? (
              <TextArea
                value={tsCode}
                onChange={(e) => setTsCode(e.target.value)}
                placeholder="生成的 TypeScript 类型会显示在这里"
                rows={12}
                style={{ fontFamily: 'Menlo, Monaco, Consolas, "Courier New", monospace' }}
                spellCheck={false}
              />
            ) : (
              <div className="border rounded-md bg-gray-900 text-gray-100 overflow-auto" style={{ maxHeight: 320 }}>
                <pre
                  className="m-0 p-3 text-xs leading-5"
                  style={{ fontFamily: 'Menlo, Monaco, Consolas, "Courier New", monospace' }}
                  dangerouslySetInnerHTML={{ __html: tsCode ? highlightTs(tsCode) : escapeHtml('// 生成的 TypeScript 类型会显示在这里') }}
                />
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

export default IndexPopup 
